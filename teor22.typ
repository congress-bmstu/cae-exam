== Теория №22. Задачи удовлетворения ограничений. Методы решения. Эвристики. (+ привести примеры инженерных задач, сводящихся к задачам удовлетворения ограничений)

*Задача удовлетворения ограничений (ЗУО)* — это класс задач искусственного интеллекта и дискретной оптимизации, в которых требуется найти такое присваивание значений переменным, при котором выполняются все заданные ограничения.

Задача будет решена, когда каждая переменная будет иметь значение, удовлетворяющее всем наложенным на нее ограничениям. Задачи, описанные подобным образом, называют *задачами удовлетворения ограничений* _(УО)_ или *CSP*_ Constraint
Satisfaction Рrоblem_.

Цель: найти полное присваивание (каждой переменной присвоено значение из её домена), при котором *все ограничения выполнены*.
#v(1em)
*Определение задачи удовлетворения ограничений*

Определение задачи удовлетворения ограничений включает три компонента: $X$, $D$ и $C$:

- $X$ — множество переменных, $X = {X_1, ..., X_n}$;

- $D$ — множество областей определения, ${D_1, ..., D_n}$, по одной для каждой переменной;

- $C$ — множество ограничений, определяющих допустимые комбинации значений.
#v(1em)
Область определения (или домен) $D_i$ состоит из множества допустимых значений ${v_1, ..., v_k}$ для переменной $X_i$. Например, булева переменная будет иметь область определения _{true, false}_. Различные переменные могут иметь разные области определения разных размеров. Каждое ограничение $C_j$ состоит из пар _(scope, rel)_, где _scope_ является некоторым подмножеством (или кортежем) переменных, которые принимают участие в ограничении, а _rel_ является таблицей (или *отношением*), определяющей, какие значения могут принимать эти переменные. Отношение может быть представлено как явно заданное множество всех кортежей значений, которые удовлетворяют ограничению, или как функция, вычислив которую, можно установить, является ли кортеж членом отношения. Например, если две переменные $X_1$ и $X_2$ имеют одинаковую область определения ${1, 2, 3}$, то ограничение, требующее, чтобы значение переменной $X_1$ всегда было больше значения переменной $X_2$, можно записать как $((X_1, X_2), {(3, 1), (3, 2), (2, 1)})$ или как $((X_1, X_2), X_1 > X_2)$.
#v(1em)
Задачи УО имеют дело с *присваиваниями* значений переменным, ${X_i = v_j, X_j = v_k, ...}$. Присваивание, которое не нарушает никаких ограничений, называется *совместимым* или допустимым присваиванием. *Полным* называется такое присваивание, в котором каждая переменная получает значение, а решением задачи УО является полное присваивание, удовлетворяющее всем ограничениям. В *частичном присваивании* одна или более переменных не имеют значения, а *частичное решение* является частичным присваиванием, которое является совместимым. В общем случае поиск решения CSP является NP-полной задачей, хотя существуют важные подклассы задач удовлетворения ограничений, которые могут быть решены весьма эффективно.
#v(1em)

*Методы решения ЗУО*

1. Основные методы решения

Методы построения решения задачи удовлетворения ограничений (УО) могут быть разбиты на три класса:

- *Первый класс* содержит варианты поиска с возвратами. Эти алгоритмы строят решение с возможностью расширения частичного решения шаг за шагом, используя различные эвристики и применяя разумные стратегии возврата из тупиковых вершин. Снижение размера задачи позволяет уменьшить размеры пространства поиска.

- *Алгоритмы распространения ограничений* исключают некоторые элементы, не входящие в решение, из пространства поиска. В общем, эти алгоритмы не исключают все элементы, не входящие в решение, и, следовательно, они не строят сами по себе решения, а используются либо для preprocessing задачи до использования алгоритма другого типа, либо перемежаются с шагами алгоритма другого типа — например, поиска с возвратами — для повышения производительности последнего.

- Наконец, *структурные алгоритмы* используют информацию о структуре первичного или двойственного графа ограничений задачи. Имеются различные алгоритмы этого класса, при этом некоторые производят декомпозицию исходной задачи УО на слабо связанные подзадачи, которые могут быть решены с помощью методов из предыдущих двух классов. Таким образом, структурные алгоритмы могут также использоваться в сочетании с алгоритмами других типов. Все алгоритмы из указанных выше трех классов систематически исследуют пространство решений. Эти алгоритмы:

  - _корректны_, то есть они заканчивают работу с присвоением значений всем переменным, которое является решением;
  - _полны_, то есть они способны исследовать всё пространство поиска и найти все решения.

2. *Поиск с возвратами*

Формулировка задачи УО в виде задачи поиска позволяет решать задачи УО с помощью алгоритмов поиска.

Поиск в глубину, в котором каждый раз выбирается значение для одной переменной и выполняется возврат, если больше не остаётся допустимых значений, которые можно было бы присвоить переменной, называется *поиском с возвратами* (backtracking).

Дерево присвоений значений переменным — это дерево, в котором каждая вершина соответствует множеству присвоений. Корень дерева отвечает пустому множеству присвоений. В каждой вершине $v$ выбирается переменная, которой в $v$ не было присвоено значение. Алгоритмы поиска с возвратами выполняют поиск в глубину в этих деревьях присвоений значений.

Алгоритмы поиска с возвратами — это алгоритмы систематического поиска для задач УО, которые используют частичные решения, которые строятся путём поочерёдного присвоения значений переменным. Если алгоритм обнаруживает тупиковую вершину, в которой частичное решение не имеет совместного расширения, то выбор последнего присвоения отменяется и делается попытка присвоения другого значения. Этот процесс повторяется до тех пор, пока не будут исчерпаны все возможности и/или не будет найдено решение. Алгоритмы поиска с возвратами являются полными в том смысле, что они находят решение, если оно существует. Различные алгоритмы поиска с возвратами различаются по скорости обнаружения тупиковых вершин, а также по тому, насколько далеко они способны делать возврат. Алгоритм поиска с возвратами характеризуется экспоненциальной временной сложностью, но является линейным по используемой памяти.

3. *Интеллектуальный поиск с возвратами*

_Интеллектуальный поиск с возвратами_ (intelligent backtracking) [42], [86] — это собирательный термин, объединяющий алгоритмы поиска с возвратами, позволяющие решателю обнаружить, что конкретная тупиковая вершина дерева присвоения значений не связана с некоторыми присвоениями. А именно, если тупиковая вершина была обнаружена на уровне $l$ и алгоритм может выяснить, что присвоения, сделанные на уровнях $j ∈ {k+1, ..., l}$, не относятся к этой тупиковой вершине, он может перейти обратно к уровню $k$, поскольку попытка различных присвоений этим переменным постоянно приводила бы к тупиковой вершине. Таким образом, вместо хронологического поиска с возвратами на уровень $l-1$, этот алгоритм позволяет избежать лишней работы, связанной с попыткой присвоения различных значений переменным на этих уровнях, и вместо этого при возврате прямо пытается присвоить другое значение на более раннем уровне $k$.

*К разумным методам интеллектуального поиска с возвратами относятся:* _обратный переход_ (backjumping), _обратный переход, управляемый конфликтами_ (conflict-directed backjumping), _обратная проверка_ (backchecking), _проставление обратных меток_ (backmarking).

Методы обратного перехода являются одним из главных средств для преодоления тенденций поиска с возвратами к повторному нахождению одних и тех же тупиковых вершин. Тупиковая вершина встречается, когда у $x_i$ не остаётся совместных значений, в этом случае алгоритм поиска с возвратами возвращается в вершину $x_{i-1}$. Пусть существует новое значение для $x_{i-1}$, но нет ограничений между $x_i$ и $x_{i-1}$. Тупиковая вершина будет в $x_i$ для любого значения переменной $x_{i-1}$, пока не будут исчерпаны все значения переменной $x_{i-1}$. Мы можем обойти эту ситуацию путём определения переменной-виновницы тупика и последующим немедленным обратным переходом к присвоению значения переменной-виновницы тупика (конфликта), вместо повторного фиксирования значения хронологически предшествующей переменной. Определение переменной-виновницы тупика в алгоритме поиска с возвратами основано на понятии _конфликтного множества_. Для простоты изложения будем предполагать, что переменные упорядочены следующим образом: $h = {x_1, ..., x_n}$.

#v(1em)
*Эвристики для решения ЗУО*

*Эвристика* -- это упрощённый метод, правило или подход, который помогает быстро находить решения сложных задач, особенно когда точный или оптимальный алгоритм неизвестен, слишком сложен или требует слишком много ресурсов.

1. Алгоритмы локального поиска являются очень эффективными средствами решения многих задач УО. В них используется следующая формулировка с полным состоянием: в каждом состоянии присваивается значение каждой переменной, а при поиске за один раз изменяется значение одной переменной. Наиболее очевидным подходом являлся бы выбор такого значения, которое приведёт нас к минимальному количеству конфликтов с другими переменными -- это эвристика *минимальных конфликтов*. Алгоритм минимальных конфликтов показал себя невероятно эффективным при решении многих задач CSP.

2. Простейшей стратегией является использование заданной статической упорядоченности: переменные выбираются в порядке ${X_1, X_2, ...}$. Другим простым вариантом является выбор переменных случайным образом. Ни одна из этих стратегий не является оптимальной. Эта довольно очевидная идея выбора в первую очередь переменной с наименьшим количеством "допустимых" значений называется эвристикой *с минимальным количеством оставшихся значений (Minimum Remaining Values — MRV)*. Её также часто называют эвристикой с "переменной, на которую наложено наибольшее количество ограничений" или эвристикой "первого неудачного завершения", — последнее название применяется потому, что эта эвристическая функция предусматривает выбор переменной, с наибольшей вероятностью приводящей к скорой неудаче, усекая тем самым дерево поиска. Если есть переменная $X$, уже не имеющая оставшихся допустимых значений, эвристическая функция MRV первой выберет именно её, и неудача будет обнаружена немедленно, что позволит избежать бессмысленных поисков среди других переменных, которые в любом случае закончатся неудачей после того, как в конечном итоге будет выбрана переменная $X$. Эвристика MRV обычно работает лучше, чем случайное или статическое упорядочение, иногда на порядок или более, хотя результаты варьируют в зависимости от задачи.

3. Как только переменная будет выбрана, алгоритм должен принять решение, в каком порядке будут анализироваться её значения. В этом случае эффективной будет эвристика *с наименьшим ограничительным значением*. В ней предпочтение отдаётся значению, при котором из рассмотрения исключается наименьшее количество вариантов выбора значений для соседних переменных в графе ограничений. Вообще говоря, в этой эвристике предпринимается попытка сохранить максимальную гибкость для последующих присвоений значений переменным.

#v(1em)
*Примеры инженерных задач, сводящихся к ЗУО*
1. *Задача составления расписания*

Важной для практических приложений являлась задача составления расписания, состоящая в упорядочении набора заданий (работ). В этой задаче задан список заданий и ограничения, какие задания могут быть выполнены одновременно, выполнение каких заданий должно предшествовать выполнению других и т. д.

Для решения этой задачи нужно найти назначение времён начал работ заданиям так, чтобы все ограничения удовлетворялись.

Рассмотрим задачу составления расписания для пяти заданий _T1, T2, T3, T4, T5_, каждое из которых может быть выполнено за один час. Задания могут начинаться в 1:00, 2:00 или 3:00. Любые работы могут выполняться одновременно, учитывая ограничения на то, что _T1_ может начинаться после _T3, T3_ может начинаться до _T4_ и после _T5, T2_ не может начинаться в то же время, что _T1_ или _T4, T4_ не может начинаться в 2:00.

Можно построить модель составления графика, введя пять переменных, соответствующих заданиям с доменами ${1:00, 2:00, 3:00}$. Соответствующий граф ограничений показан на рисунке ниже:
#image("images/teor22_photo1.PNG", width: 100%)
#v(1em)
2. *Реляционная база данных*

Реляционная база данных может быть рассмотрена как конечное множество таблиц. Таблица состоит из схемы и конкретных данных, где схема -- конечное множество _атрибутов_, причём каждый атрибут имеет соответствующее ему множество возможных значений, называемое _доменом_. Конкретные данные -- это конечное множество строк, где каждая строка -- отображение, ставящее в соответствие каждому атрибуту схемы значение из её домена.

Стандартной задачей для реляционных БД является задача оценки конъюнктивного запроса, в котором спрашивается, имеет ли решение конъюнктивный запрос, то есть запрос вида $p_1 ∧ ⋯ ∧ p_q$, где $p_1, ..., p_q$ — атомарные формулы. Конъюнктивный запрос над реляционной базой данных соответствует конкретному примеру задачи удовлетворения ограничений, что достигается простой заменой терминов: «атрибуты» заменяются на «переменные», «таблицы» — на «ограничения», «схема» — на «диапазон», «конкретные данные» — на «отношение ограничения», а «строки» — на «кортежи».

Значит, конъюнктивный запрос эквивалентен конкретному примеру задачи удовлетворения ограничений, переменные которой — это атрибуты запроса. Для каждой атомарной формулы $ρ_i$ в запросе найдётся ограничение $C$ такое, что диапазон ограничения $C$ — это список переменных формулы $ρ_i$, а отношение ограничения $C$ — это множество моделей $ρ_i$.
#v(1em)
3. *Проектирование электронных схем* 

*Задача:* Разместить компоненты на печатной плате так, чтобы минимизировать пересечения проводников и соблюсти тепловые ограничения.

*Переменные:* Положение компонентов, трассировка соединений.

*Ограничения:* Минимальное расстояние между компонентами, тепловыделение, длина проводников.
